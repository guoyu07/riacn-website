<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>第 2 章相关源代码 &mdash; Redis 实战</title>
    
    <link rel="stylesheet" href="../_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Redis 实战" href="../index.html" />
    <link rel="next" title="第 3 章相关源代码" href="chapter3.html" />
    <link rel="prev" title="第 1 章相关源代码" href="chapter1.html" /> 

<!--[if lte IE 6]>
<link rel="stylesheet" href="../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->


  </head>
  <body>


    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="chapter3.html" title="第 3 章相关源代码"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="chapter1.html" title="第 1 章相关源代码"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Redis 实战</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="id1">
<h1>第 2 章相关源代码<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<div class="highlight-python"><div class="highlight"><pre># coding: utf-8

import json
import threading
import time
import unittest
import urlparse
import uuid

QUIT = False

# 代码清单 2-1
# &lt;start id=&quot;_1311_14471_8266&quot;/&gt;
def check_token(conn, token):
    return conn.hget(&#39;login:&#39;, token)   # 尝试获取并返回令牌对应的用户。
# &lt;end id=&quot;_1311_14471_8266&quot;/&gt;


# 代码清单 2-2
# &lt;start id=&quot;_1311_14471_8265&quot;/&gt;
def update_token(conn, token, user, item=None):
    # 获取当前时间戳。
    timestamp = time.time()
    # 维持令牌与已登录用户之间的映射。
    conn.hset(&#39;login:&#39;, token, user)
    # 记录令牌最后一次出现的时间。
    conn.zadd(&#39;recent:&#39;, token, timestamp)
    if item:
        # 记录用户浏览过的商品。
        conn.zadd(&#39;viewed:&#39; + token, item, timestamp)
        # 移除旧的记录，只保留用户最近浏览过的25个商品。
        conn.zremrangebyrank(&#39;viewed:&#39; + token, 0, -26)
# &lt;end id=&quot;_1311_14471_8265&quot;/&gt;


# 代码清单 2-3
# &lt;start id=&quot;_1311_14471_8270&quot;/&gt;
QUIT = False
LIMIT = 10000000

def clean_sessions(conn):
    while not QUIT:
        # 找出目前已有令牌的数量。
        size = conn.zcard(&#39;recent:&#39;)
        # 令牌数量未超过限制，休眠并在之后重新检查。
        if size &lt;= LIMIT:
            time.sleep(1)
            continue

        #  获取需要移除的令牌ID。
        end_index = min(size - LIMIT, 100)
        tokens = conn.zrange(&#39;recent:&#39;, 0, end_index-1)

        # 为那些将要被删除的令牌构建键名。
        session_keys = []
        for token in tokens:
            session_keys.append(&#39;viewed:&#39; + token)

        # 移除最旧的那些令牌。
        conn.delete(*session_keys)
        conn.hdel(&#39;login:&#39;, *tokens)
        conn.zrem(&#39;recent:&#39;, *tokens)
# &lt;end id=&quot;_1311_14471_8270&quot;/&gt;


# 代码清单 2-4
# &lt;start id=&quot;_1311_14471_8279&quot;/&gt;
def add_to_cart(conn, session, item, count):
    if count &lt;= 0:
        # 从购物车里面移除指定的商品。
        conn.hrem(&#39;cart:&#39; + session, item) 
    else:
        # 将指定的商品添加到购物车。
        conn.hset(&#39;cart:&#39; + session, item, count) 
# &lt;end id=&quot;_1311_14471_8279&quot;/&gt;


# 代码清单 2-5
# &lt;start id=&quot;_1311_14471_8271&quot;/&gt;
def clean_full_sessions(conn):
    while not QUIT:
        size = conn.zcard(&#39;recent:&#39;)
        if size &lt;= LIMIT:
            time.sleep(1)
            continue

        end_index = min(size - LIMIT, 100)
        sessions = conn.zrange(&#39;recent:&#39;, 0, end_index-1)

        session_keys = []
        for sess in sessions:
            session_keys.append(&#39;viewed:&#39; + sess)
            session_keys.append(&#39;cart:&#39; + sess)   # 新增加的这行代码用于删除旧会话对应用户的购物车。

        conn.delete(*session_keys)
        conn.hdel(&#39;login:&#39;, *sessions)
        conn.zrem(&#39;recent:&#39;, *sessions)
# &lt;end id=&quot;_1311_14471_8271&quot;/&gt;


# 代码清单 2-6
# &lt;start id=&quot;_1311_14471_8291&quot;/&gt;
def cache_request(conn, request, callback):
    # 对于不能被缓存的请求，直接调用回调函数。
    if not can_cache(conn, request):
        return callback(request)

    # 将请求转换成一个简单的字符串键，方便之后进行查找。
    page_key = &#39;cache:&#39; + hash_request(request) 
    # 尝试查找被缓存的页面。
    content = conn.get(page_key)

    if not content:
        # 如果页面还没有被缓存，那么生成页面。
        content = callback(request)
        # 将新生成的页面放到缓存里面。
        conn.setex(page_key, content, 300)

    # 返回页面。
    return content
# &lt;end id=&quot;_1311_14471_8291&quot;/&gt;


# 代码清单 2-7
# &lt;start id=&quot;_1311_14471_8287&quot;/&gt;
def schedule_row_cache(conn, row_id, delay):
    # 先设置数据行的延迟值。
    conn.zadd(&#39;delay:&#39;, row_id, delay) 
    # 立即缓存数据行。
    conn.zadd(&#39;schedule:&#39;, row_id, time.time()) 
# &lt;end id=&quot;_1311_14471_8287&quot;/&gt;


# 代码清单 2-8
# &lt;start id=&quot;_1311_14471_8292&quot;/&gt;
def cache_rows(conn):
    while not QUIT:
        # 尝试获取下一个需要被缓存的数据行以及该行的调度时间戳，
        # 命令会返回一个包含零个或一个元组（tuple）的列表。
        next = conn.zrange(&#39;schedule:&#39;, 0, 0, withscores=True) 
        now = time.time()
        if not next or next[0][1] &gt; now:
            # 暂时没有行需要被缓存，休眠50毫秒后重试。
            time.sleep(.05) 
            continue

        row_id = next[0][0]
        # 获取下一次调度前的延迟时间。
        delay = conn.zscore(&#39;delay:&#39;, row_id)
        if delay &lt;= 0:
            # 不必再缓存这个行，将它从缓存中移除。
            conn.zrem(&#39;delay:&#39;, row_id) 
            conn.zrem(&#39;schedule:&#39;, row_id)
            conn.delete(&#39;inv:&#39; + row_id)
            continue

        # 读取数据行。
        row = Inventory.get(row_id)
        # 更新调度时间并设置缓存值。
        conn.zadd(&#39;schedule:&#39;, row_id, now + delay)         
        conn.set(&#39;inv:&#39; + row_id, json.dumps(row.to_dict())) 
# &lt;end id=&quot;_1311_14471_8292&quot;/&gt;


# 代码清单 2-9
# &lt;start id=&quot;_1311_14471_8298&quot;/&gt;
def update_token(conn, token, user, item=None):
    timestamp = time.time()
    conn.hset(&#39;login:&#39;, token, user)
    conn.zadd(&#39;recent:&#39;, token, timestamp)
    if item:
        conn.zadd(&#39;viewed:&#39; + token, item, timestamp)
        conn.zremrangebyrank(&#39;viewed:&#39; + token, 0, -26)
        conn.zincrby(&#39;viewed:&#39;, item, -1)                   # 这行代码是新添加的。
# &lt;end id=&quot;_1311_14471_8298&quot;/&gt;


# 代码清单 2-10
# &lt;start id=&quot;_1311_14471_8288&quot;/&gt;
def rescale_viewed(conn):
    while not QUIT:
        # 删除所有排名在20 000名之后的商品。
        conn.zremrangebyrank(&#39;viewed:&#39;, 0, -20001) 
        # 将浏览次数降低为原来的一半
        conn.zinterstore(&#39;viewed:&#39;, {&#39;viewed:&#39;: .5}) 
        # 5分钟之后再执行这个操作。
        time.sleep(300) 
# &lt;end id=&quot;_1311_14471_8288&quot;/&gt;


# 代码清单 2-11
# &lt;start id=&quot;_1311_14471_8289&quot;/&gt;
def can_cache(conn, request):
    # 尝试从页面里面取出商品ID。
    item_id = extract_item_id(request)
    # 检查这个页面能否被缓存以及这个页面是否为商品页面。
    if not item_id or is_dynamic(request):
        return False
    # 取得商品的浏览次数排名。
    rank = conn.zrank(&#39;viewed:&#39;, item_id)
    # 根据商品的浏览次数排名来判断是否需要缓存这个页面。
    return rank is not None and rank &lt; 10000 
# &lt;end id=&quot;_1311_14471_8289&quot;/&gt;


#--------------- 以下是用于测试代码的辅助函数 --------------------------------

def extract_item_id(request):
    parsed = urlparse.urlparse(request)
    query = urlparse.parse_qs(parsed.query)
    return (query.get(&#39;item&#39;) or [None])[0]

def is_dynamic(request):
    parsed = urlparse.urlparse(request)
    query = urlparse.parse_qs(parsed.query)
    return &#39;_&#39; in query

def hash_request(request):
    return str(hash(request))

class Inventory(object):
    def __init__(self, id):
        self.id = id

    @classmethod
    def get(cls, id):
        return Inventory(id)

    def to_dict(self):
        return {&#39;id&#39;:self.id, &#39;data&#39;:&#39;data to cache...&#39;, &#39;cached&#39;:time.time()}

class TestCh02(unittest.TestCase):
    def setUp(self):
        import redis
        self.conn = redis.Redis(db=15)

    def tearDown(self):
        conn = self.conn
        to_del = (
            conn.keys(&#39;login:*&#39;) + conn.keys(&#39;recent:*&#39;) + conn.keys(&#39;viewed:*&#39;) +
            conn.keys(&#39;cart:*&#39;) + conn.keys(&#39;cache:*&#39;) + conn.keys(&#39;delay:*&#39;) + 
            conn.keys(&#39;schedule:*&#39;) + conn.keys(&#39;inv:*&#39;))
        if to_del:
            self.conn.delete(*to_del)
        del self.conn
        global QUIT, LIMIT
        QUIT = False
        LIMIT = 10000000
        print
        print

    def test_login_cookies(self):
        conn = self.conn
        global LIMIT, QUIT
        token = str(uuid.uuid4())

        update_token(conn, token, &#39;username&#39;, &#39;itemX&#39;)
        print &quot;We just logged-in/updated token:&quot;, token
        print &quot;For user:&quot;, &#39;username&#39;
        print

        print &quot;What username do we get when we look-up that token?&quot;
        r = check_token(conn, token)
        print r
        print
        self.assertTrue(r)


        print &quot;Let&#39;s drop the maximum number of cookies to 0 to clean them out&quot;
        print &quot;We will start a thread to do the cleaning, while we stop it later&quot;

        LIMIT = 0
        t = threading.Thread(target=clean_sessions, args=(conn,))
        t.setDaemon(1) # to make sure it dies if we ctrl+C quit
        t.start()
        time.sleep(1)
        QUIT = True
        time.sleep(2)
        if t.isAlive():
            raise Exception(&quot;The clean sessions thread is still alive?!?&quot;)

        s = conn.hlen(&#39;login:&#39;)
        print &quot;The current number of sessions still available is:&quot;, s
        self.assertFalse(s)

    def test_shoppping_cart_cookies(self):
        conn = self.conn
        global LIMIT, QUIT
        token = str(uuid.uuid4())

        print &quot;We&#39;ll refresh our session...&quot;
        update_token(conn, token, &#39;username&#39;, &#39;itemX&#39;)
        print &quot;And add an item to the shopping cart&quot;
        add_to_cart(conn, token, &quot;itemY&quot;, 3)
        r = conn.hgetall(&#39;cart:&#39; + token)
        print &quot;Our shopping cart currently has:&quot;, r
        print

        self.assertTrue(len(r) &gt;= 1)

        print &quot;Let&#39;s clean out our sessions and carts&quot;
        LIMIT = 0
        t = threading.Thread(target=clean_full_sessions, args=(conn,))
        t.setDaemon(1) # to make sure it dies if we ctrl+C quit
        t.start()
        time.sleep(1)
        QUIT = True
        time.sleep(2)
        if t.isAlive():
            raise Exception(&quot;The clean sessions thread is still alive?!?&quot;)

        r = conn.hgetall(&#39;cart:&#39; + token)
        print &quot;Our shopping cart now contains:&quot;, r

        self.assertFalse(r)

    def test_cache_request(self):
        conn = self.conn
        token = str(uuid.uuid4())

        def callback(request):
            return &quot;content for &quot; + request

        update_token(conn, token, &#39;username&#39;, &#39;itemX&#39;)
        url = &#39;http://test.com/?item=itemX&#39;
        print &quot;We are going to cache a simple request against&quot;, url
        result = cache_request(conn, url, callback)
        print &quot;We got initial content:&quot;, repr(result)
        print

        self.assertTrue(result)

        print &quot;To test that we&#39;ve cached the request, we&#39;ll pass a bad callback&quot;
        result2 = cache_request(conn, url, None)
        print &quot;We ended up getting the same response!&quot;, repr(result2)

        self.assertEquals(result, result2)

        self.assertFalse(can_cache(conn, &#39;http://test.com/&#39;))
        self.assertFalse(can_cache(conn, &#39;http://test.com/?item=itemX&amp;_=1234536&#39;))

    def test_cache_rows(self):
        import pprint
        conn = self.conn
        global QUIT
        
        print &quot;First, let&#39;s schedule caching of itemX every 5 seconds&quot;
        schedule_row_cache(conn, &#39;itemX&#39;, 5)
        print &quot;Our schedule looks like:&quot;
        s = conn.zrange(&#39;schedule:&#39;, 0, -1, withscores=True)
        pprint.pprint(s)
        self.assertTrue(s)

        print &quot;We&#39;ll start a caching thread that will cache the data...&quot;
        t = threading.Thread(target=cache_rows, args=(conn,))
        t.setDaemon(1)
        t.start()

        time.sleep(1)
        print &quot;Our cached data looks like:&quot;
        r = conn.get(&#39;inv:itemX&#39;)
        print repr(r)
        self.assertTrue(r)
        print
        print &quot;We&#39;ll check again in 5 seconds...&quot;
        time.sleep(5)
        print &quot;Notice that the data has changed...&quot;
        r2 = conn.get(&#39;inv:itemX&#39;)
        print repr(r2)
        print
        self.assertTrue(r2)
        self.assertTrue(r != r2)

        print &quot;Let&#39;s force un-caching&quot;
        schedule_row_cache(conn, &#39;itemX&#39;, -1)
        time.sleep(1)
        r = conn.get(&#39;inv:itemX&#39;)
        print &quot;The cache was cleared?&quot;, not r
        print
        self.assertFalse(r)

        QUIT = True
        time.sleep(2)
        if t.isAlive():
            raise Exception(&quot;The database caching thread is still alive?!?&quot;)

    # We aren&#39;t going to bother with the top 10k requests are cached, as
    # we already tested it as part of the cached requests test.

if __name__ == &#39;__main__&#39;:
    unittest.main()
</pre></div>
</div>
</div>



            <div class="section" id="discuss">
    <h2>
        讨论
        <a class="headerlink" href="#discuss" title="永久链接至标题">¶</a>
    </h2>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'redisinaction'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="chapter3.html" title="第 3 章相关源代码"
             >next</a> |</li>
        <li class="right" >
          <a href="chapter1.html" title="第 1 章相关源代码"
             >previous</a> |</li>
        <li><a href="../index.html">Redis 实战</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, 黄健宏（huangz）.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>