<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>第 3 章相关源代码 &mdash; Redis 实战</title>
    
    <link rel="stylesheet" href="../_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Redis 实战" href="../index.html" />
    <link rel="next" title="第 4 章相关源代码" href="chapter4.html" />
    <link rel="prev" title="第 2 章相关源代码" href="chapter2.html" /> 

<!--[if lte IE 6]>
<link rel="stylesheet" href="../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->


  </head>
  <body>


    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="chapter4.html" title="第 4 章相关源代码"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="chapter2.html" title="第 2 章相关源代码"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Redis 实战</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="id1">
<h1>第 3 章相关源代码<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># coding: utf-8</span>

<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">unittest</span>

<span class="kn">import</span> <span class="nn">redis</span>

<span class="n">ONE_WEEK_IN_SECONDS</span> <span class="o">=</span> <span class="mi">7</span> <span class="o">*</span> <span class="mi">86400</span>
<span class="n">VOTE_SCORE</span> <span class="o">=</span> <span class="mi">432</span>
<span class="n">ARTICLES_PER_PAGE</span> <span class="o">=</span> <span class="mi">25</span>


<span class="c"># 代码清单 3-1</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd"># &lt;start id=&quot;string-calls-1&quot;/&gt;</span>
<span class="sd">&gt;&gt;&gt; conn = redis.Redis()</span>
<span class="sd">&gt;&gt;&gt; conn.get(&#39;key&#39;)             # 尝试获取一个不存在的键将得到一个None值，终端不会显示这个值。</span>
<span class="sd">&gt;&gt;&gt; conn.incr(&#39;key&#39;)            # 我们既可以对不存在的键执行自增操作，</span>
<span class="sd">1                               # 也可以通过可选的参数来指定自增操作的增量。</span>
<span class="sd">&gt;&gt;&gt; conn.incr(&#39;key&#39;, 15)        #</span>
<span class="sd">16                              #</span>
<span class="sd">&gt;&gt;&gt; conn.decr(&#39;key&#39;, 5)         # 和自增操作一样，</span>
<span class="sd">11                              # 执行自减操作的函数也可以通过可选的参数来指定减量。</span>
<span class="sd">&gt;&gt;&gt; conn.get(&#39;key&#39;)             # 在尝试获取一个键的时候，命令以字符串格式返回被存储的整数。</span>
<span class="sd">&#39;11&#39;                            #</span>
<span class="sd">&gt;&gt;&gt; conn.set(&#39;key&#39;, &#39;13&#39;)       # 即使在设置键时输入的值为字符串，</span>
<span class="sd">True                            # 但只要这个值可以被解释为整数，</span>
<span class="sd">&gt;&gt;&gt; conn.incr(&#39;key&#39;)            # 我们就可以把它当作整数来处理。</span>
<span class="sd">14                              #</span>
<span class="sd"># &lt;end id=&quot;string-calls-1&quot;/&gt;</span>
<span class="sd">&#39;&#39;&#39;</span>


<span class="c"># 代码清单 3-2</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd"># &lt;start id=&quot;string-calls-2&quot;/&gt;</span>
<span class="sd">&gt;&gt;&gt; conn.append(&#39;new-string-key&#39;, &#39;hello &#39;)     # 将字符串&#39;hello&#39;追加到目前并不存在的&#39;new-string-key&#39;键里。</span>
<span class="sd">6L                                              # APPEND命令在执行之后会返回字符串当前的长度。</span>
<span class="sd">&gt;&gt;&gt; conn.append(&#39;new-string-key&#39;, &#39;world!&#39;)</span>
<span class="sd">12L                                             #</span>
<span class="sd">&gt;&gt;&gt; conn.substr(&#39;new-string-key&#39;, 3, 7)         # Redis的索引以0为开始，在进行范围访问时，范围的终点（endpoint）默认也包含在这个范围之内。</span>
<span class="sd">&#39;lo wo&#39;                                         # 字符串&#39;lo wo&#39;位于字符串&#39;hello world!&#39;的中间。</span>
<span class="sd">&gt;&gt;&gt; conn.setrange(&#39;new-string-key&#39;, 0, &#39;H&#39;)     # 对字符串执行范围设置操作。</span>
<span class="sd">12                                              # SETRANGE命令在执行之后同样会返回字符串的当前总长度。</span>
<span class="sd">&gt;&gt;&gt; conn.setrange(&#39;new-string-key&#39;, 6, &#39;W&#39;)</span>
<span class="sd">12</span>
<span class="sd">&gt;&gt;&gt; conn.get(&#39;new-string-key&#39;)                  # 查看字符串的当前值。</span>
<span class="sd">&#39;Hello World!&#39;                                  # 前面执行的两个SETRANGE命令成功地将字母h和w从原来的小写改成了大写。</span>
<span class="sd">&gt;&gt;&gt; conn.setrange(&#39;new-string-key&#39;, 11, &#39;, how are you?&#39;)   # SETRANGE命令既可以用于替换字符串里已有的内容，又可以用于增长字符串。</span>
<span class="sd">25</span>
<span class="sd">&gt;&gt;&gt; conn.get(&#39;new-string-key&#39;)</span>
<span class="sd">&#39;Hello World, how are you?&#39;                     # 前面执行的SETRANGE命令移除了字符串末尾的感叹号，并将更多字符追加到了字符串末尾。</span>
<span class="sd">&gt;&gt;&gt; conn.setbit(&#39;another-key&#39;, 2, 1)            # 对超出字符串长度的二进制位进行设置时，超出的部分会被填充为空字节。</span>
<span class="sd">0                                               # SETBIT命令会返回二进制位被设置之前的值。</span>
<span class="sd">&gt;&gt;&gt; conn.setbit(&#39;another-key&#39;, 7, 1)            # 在对Redis存储的二进制位进行解释（interpret）时，</span>
<span class="sd">0                                               # 请记住Redis存储的二进制位是按照偏移量从高到低排列的。</span>
<span class="sd">&gt;&gt;&gt; conn.get(&#39;another-key&#39;)                     #</span>
<span class="sd">&#39;!&#39;                                             # 通过将第2个二进制位以及第7个二进制位的值设置为1，键的值将变为‘!’，即字符33 。</span>
<span class="sd"># &lt;end id=&quot;string-calls-2&quot;/&gt;</span>
<span class="sd">&#39;&#39;&#39;</span>


<span class="c"># 代码清单 3-3</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd"># &lt;start id=&quot;list-calls-1&quot;/&gt;</span>
<span class="sd">&gt;&gt;&gt; conn.rpush(&#39;list-key&#39;, &#39;last&#39;)          # 在向列表推入元素时，</span>
<span class="sd">1L                                          # 推入操作执行完毕之后会返回列表当前的长度。</span>
<span class="sd">&gt;&gt;&gt; conn.lpush(&#39;list-key&#39;, &#39;first&#39;)         # 可以很容易地对列表的两端执行推入操作。</span>
<span class="sd">2L</span>
<span class="sd">&gt;&gt;&gt; conn.rpush(&#39;list-key&#39;, &#39;new last&#39;)</span>
<span class="sd">3L</span>
<span class="sd">&gt;&gt;&gt; conn.lrange(&#39;list-key&#39;, 0, -1)          # 从语义上来说，列表的左端为开头，右端为结尾。</span>
<span class="sd">[&#39;first&#39;, &#39;last&#39;, &#39;new last&#39;]               #</span>
<span class="sd">&gt;&gt;&gt; conn.lpop(&#39;list-key&#39;)                   # 通过重复地弹出列表左端的元素，</span>
<span class="sd">&#39;first&#39;                                     # 可以按照从左到右的顺序来获取列表中的元素。</span>
<span class="sd">&gt;&gt;&gt; conn.lpop(&#39;list-key&#39;)                   #</span>
<span class="sd">&#39;last&#39;                                      #</span>
<span class="sd">&gt;&gt;&gt; conn.lrange(&#39;list-key&#39;, 0, -1)</span>
<span class="sd">[&#39;new last&#39;]</span>
<span class="sd">&gt;&gt;&gt; conn.rpush(&#39;list-key&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;)   # 可以同时推入多个元素。</span>
<span class="sd">4L</span>
<span class="sd">&gt;&gt;&gt; conn.lrange(&#39;list-key&#39;, 0, -1)</span>
<span class="sd">[&#39;new last&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">&gt;&gt;&gt; conn.ltrim(&#39;list-key&#39;, 2, -1)           # 可以从列表的左端、右端或者左右两端删减任意数量的元素。</span>
<span class="sd">True                                        #</span>
<span class="sd">&gt;&gt;&gt; conn.lrange(&#39;list-key&#39;, 0, -1)          #</span>
<span class="sd">[&#39;b&#39;, &#39;c&#39;]                                  #</span>
<span class="sd"># &lt;end id=&quot;list-calls-1&quot;/&gt;</span>
<span class="sd">&#39;&#39;&#39;</span>


<span class="c"># 代码清单 3-4</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd"># &lt;start id=&quot;list-calls-2&quot;/&gt;</span>
<span class="sd">&gt;&gt;&gt; conn.rpush(&#39;list&#39;, &#39;item1&#39;)             # 将一些元素添加到两个列表里面。</span>
<span class="sd">1                                           #</span>
<span class="sd">&gt;&gt;&gt; conn.rpush(&#39;list&#39;, &#39;item2&#39;)             #</span>
<span class="sd">2                                           #</span>
<span class="sd">&gt;&gt;&gt; conn.rpush(&#39;list2&#39;, &#39;item3&#39;)            #</span>
<span class="sd">1                                           #</span>
<span class="sd">&gt;&gt;&gt; conn.brpoplpush(&#39;list2&#39;, &#39;list&#39;, 1)     # 将一个元素从一个列表移动到另一个列表，</span>
<span class="sd">&#39;item3&#39;                                     # 并返回被移动的元素。</span>
<span class="sd">&gt;&gt;&gt; conn.brpoplpush(&#39;list2&#39;, &#39;list&#39;, 1)     # 当列表不包含任何元素时，阻塞弹出操作会在给定的时限内等待可弹出的元素出现，并在时限到达后返回None（交互终端不会打印这个值）。</span>
<span class="sd">&gt;&gt;&gt; conn.lrange(&#39;list&#39;, 0, -1)              # 弹出“list2”最右端的元素，</span>
<span class="sd">[&#39;item3&#39;, &#39;item1&#39;, &#39;item2&#39;]                 # 并将弹出的元素推入到“list”的左端。</span>
<span class="sd">&gt;&gt;&gt; conn.brpoplpush(&#39;list&#39;, &#39;list2&#39;, 1)</span>
<span class="sd">&#39;item2&#39;</span>
<span class="sd">&gt;&gt;&gt; conn.blpop([&#39;list&#39;, &#39;list2&#39;], 1)        # BLPOP命令会从左到右地检查传入的列表，</span>
<span class="sd">(&#39;list&#39;, &#39;item3&#39;)                           # 并对最先遇到的非空列表执行弹出操作。</span>
<span class="sd">&gt;&gt;&gt; conn.blpop([&#39;list&#39;, &#39;list2&#39;], 1)        #</span>
<span class="sd">(&#39;list&#39;, &#39;item1&#39;)                           #</span>
<span class="sd">&gt;&gt;&gt; conn.blpop([&#39;list&#39;, &#39;list2&#39;], 1)        #</span>
<span class="sd">(&#39;list2&#39;, &#39;item2&#39;)                          #</span>
<span class="sd">&gt;&gt;&gt; conn.blpop([&#39;list&#39;, &#39;list2&#39;], 1)        #</span>
<span class="sd">&gt;&gt;&gt;</span>
<span class="sd"># &lt;end id=&quot;list-calls-2&quot;/&gt;</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="c"># &lt;start id=&quot;exercise-update-token&quot;/&gt;</span>
<span class="k">def</span> <span class="nf">update_token</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">token</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="n">item</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="n">timestamp</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">hset</span><span class="p">(</span><span class="s">&#39;login:&#39;</span><span class="p">,</span> <span class="n">token</span><span class="p">,</span> <span class="n">user</span><span class="p">)</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">zadd</span><span class="p">(</span><span class="s">&#39;recent:&#39;</span><span class="p">,</span> <span class="n">token</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">item</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="s">&#39;viewed:&#39;</span> <span class="o">+</span> <span class="n">token</span>
        <span class="c"># 如果指定的元素存在于列表当中，那么移除它</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">lrem</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
        <span class="c"># 将元素推入到列表的右端，使得 ZRANGE 和 LRANGE 可以取得相同的结果</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">rpush</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
        <span class="c"># 对列表进行修剪，让它最多只能保存 25 个元素</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">ltrim</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="o">-</span><span class="mi">25</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">zincrby</span><span class="p">(</span><span class="s">&#39;viewed:&#39;</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="c"># &lt;end id=&quot;exercise-update-token&quot;/&gt;</span>


<span class="c"># 代码清单 3-5</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd"># &lt;start id=&quot;set-calls-1&quot;/&gt;</span>
<span class="sd">&gt;&gt;&gt; conn.sadd(&#39;set-key&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;)         # SADD命令会将那些目前并不存在于集合里面的元素添加到集合里面，</span>
<span class="sd">3                                               # 并返回被添加元素的数量。</span>
<span class="sd">&gt;&gt;&gt; conn.srem(&#39;set-key&#39;, &#39;c&#39;, &#39;d&#39;)              # srem函数在元素被成功移除时返回True，</span>
<span class="sd">True                                            # 移除失败时返回False；</span>
<span class="sd">&gt;&gt;&gt; conn.srem(&#39;set-key&#39;, &#39;c&#39;, &#39;d&#39;)              # 注意这是Python客户端的一个bug，</span>
<span class="sd">False                                           # 实际上Redis的SREM命令返回的是被移除元素的数量，而不是布尔值。</span>
<span class="sd">&gt;&gt;&gt; conn.scard(&#39;set-key&#39;)                       # 查看集合包含的元素数量。</span>
<span class="sd">2                                               #</span>
<span class="sd">&gt;&gt;&gt; conn.smembers(&#39;set-key&#39;)                    # 获取集合包含的所有元素。</span>
<span class="sd">set([&#39;a&#39;, &#39;b&#39;])                                 #</span>
<span class="sd">&gt;&gt;&gt; conn.smove(&#39;set-key&#39;, &#39;set-key2&#39;, &#39;a&#39;)      # 可以很容易地将元素从一个集合移动到另一个集合。</span>
<span class="sd">True                                            #</span>
<span class="sd">&gt;&gt;&gt; conn.smove(&#39;set-key&#39;, &#39;set-key2&#39;, &#39;c&#39;)      # 在执行SMOVE命令时，</span>
<span class="sd">False                                           # 如果用户想要移动的元素不存在于第一个集合里，</span>
<span class="sd">&gt;&gt;&gt; conn.smembers(&#39;set-key2&#39;)                   # 那么移动操作就不会执行。</span>
<span class="sd">set([&#39;a&#39;])                                      #</span>
<span class="sd"># &lt;end id=&quot;set-calls-1&quot;/&gt;</span>
<span class="sd">&#39;&#39;&#39;</span>


<span class="c"># 代码清单 3-6</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd"># &lt;start id=&quot;set-calls-2&quot;/&gt;</span>
<span class="sd">&gt;&gt;&gt; conn.sadd(&#39;skey1&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;)  # 首先将一些元素添加到两个集合里面。</span>
<span class="sd">4                                           #</span>
<span class="sd">&gt;&gt;&gt; conn.sadd(&#39;skey2&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;)  #</span>
<span class="sd">4                                           #</span>
<span class="sd">&gt;&gt;&gt; conn.sdiff(&#39;skey1&#39;, &#39;skey2&#39;)            # 计算从第一个集合中移除第二个集合所有元素之后的结果。</span>
<span class="sd">set([&#39;a&#39;, &#39;b&#39;])                             #</span>
<span class="sd">&gt;&gt;&gt; conn.sinter(&#39;skey1&#39;, &#39;skey2&#39;)           # 还可以找出同时存在于两个集合中的元素。</span>
<span class="sd">set([&#39;c&#39;, &#39;d&#39;])                             #</span>
<span class="sd">&gt;&gt;&gt; conn.sunion(&#39;skey1&#39;, &#39;skey2&#39;)           # 可以找出两个结合中的所有元素。</span>
<span class="sd">set([&#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;e&#39;, &#39;d&#39;, &#39;f&#39;])         #</span>
<span class="sd"># &lt;end id=&quot;set-calls-2&quot;/&gt;</span>
<span class="sd">&#39;&#39;&#39;</span>


<span class="c"># 代码清单 3-7</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd"># &lt;start id=&quot;hash-calls-1&quot;/&gt;</span>
<span class="sd">&gt;&gt;&gt; conn.hmset(&#39;hash-key&#39;, {&#39;k1&#39;:&#39;v1&#39;, &#39;k2&#39;:&#39;v2&#39;, &#39;k3&#39;:&#39;v3&#39;})   # 使用HMSET命令可以一次将多个键值对添加到散列里面。</span>
<span class="sd">True                                                            #</span>
<span class="sd">&gt;&gt;&gt; conn.hmget(&#39;hash-key&#39;, [&#39;k2&#39;, &#39;k3&#39;])                        #  使用HMGET命令可以一次获取多个键的值。</span>
<span class="sd">[&#39;v2&#39;, &#39;v3&#39;]                                                    #</span>
<span class="sd">&gt;&gt;&gt; conn.hlen(&#39;hash-key&#39;)                                       # HLEN命令通常用于调试一个包含非常多键值对的散列。</span>
<span class="sd">3                                                               #</span>
<span class="sd">&gt;&gt;&gt; conn.hdel(&#39;hash-key&#39;, &#39;k1&#39;, &#39;k3&#39;)                           # HDEL命令在成功地移除了至少一个键值对时返回True，</span>
<span class="sd">True                                                            # 因为HDEL命令已经可以同时删除多个键值对了，所以Redis没有实现HMDEL命令。</span>
<span class="sd"># &lt;end id=&quot;hash-calls-1&quot;/&gt;</span>
<span class="sd">&#39;&#39;&#39;</span>


<span class="c"># 代码清单 3-8</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd"># &lt;start id=&quot;hash-calls-2&quot;/&gt;</span>
<span class="sd">&gt;&gt;&gt; conn.hmset(&#39;hash-key2&#39;, {&#39;short&#39;:&#39;hello&#39;, &#39;long&#39;:1000*&#39;1&#39;}) # 在考察散列的时候，我们可以只取出散列包含的键，而不必传输大的键值。</span>
<span class="sd">True                                                            #</span>
<span class="sd">&gt;&gt;&gt; conn.hkeys(&#39;hash-key2&#39;)                                     #</span>
<span class="sd">[&#39;long&#39;, &#39;short&#39;]                                               #</span>
<span class="sd">&gt;&gt;&gt; conn.hexists(&#39;hash-key2&#39;, &#39;num&#39;)                            # 检查给定的键是否存在于散列中。</span>
<span class="sd">False                                                           #</span>
<span class="sd">&gt;&gt;&gt; conn.hincrby(&#39;hash-key2&#39;, &#39;num&#39;)                            # 和字符串一样，</span>
<span class="sd">1L                                                              # 对散列中一个尚未存在的键执行自增操作时，</span>
<span class="sd">&gt;&gt;&gt; conn.hexists(&#39;hash-key2&#39;, &#39;num&#39;)                            # Redis会将键的值当作0来处理。</span>
<span class="sd">True                                                            #</span>
<span class="sd"># &lt;end id=&quot;hash-calls-2&quot;/&gt;</span>
<span class="sd">&#39;&#39;&#39;</span>


<span class="c"># 代码清单 3-9</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd"># &lt;start id=&quot;zset-calls-1&quot;/&gt;</span>
<span class="sd">&gt;&gt;&gt; conn.zadd(&#39;zset-key&#39;, &#39;a&#39;, 3, &#39;b&#39;, 2, &#39;c&#39;, 1)   # 在Python客户端执行ZADD命令需要先输入成员、后输入分值，</span>
<span class="sd">3                                                   # 这跟Redis标准的先输入分值、后输入成员的做法正好相反。</span>
<span class="sd">&gt;&gt;&gt; conn.zcard(&#39;zset-key&#39;)                          # 取得有序集合的大小可以让我们在某些情况下知道是否需要对有序集合进行修剪。</span>
<span class="sd">3                                                   #</span>
<span class="sd">&gt;&gt;&gt; conn.zincrby(&#39;zset-key&#39;, &#39;c&#39;, 3)                # 跟字符串和散列一样，</span>
<span class="sd">4.0                                                 # 有序集合的成员也可以执行自增操作。</span>
<span class="sd">&gt;&gt;&gt; conn.zscore(&#39;zset-key&#39;, &#39;b&#39;)                    # 获取单个成员的分值对于实现计数器或者排行榜之类的功能非常有用。</span>
<span class="sd">2.0                                                 #</span>
<span class="sd">&gt;&gt;&gt; conn.zrank(&#39;zset-key&#39;, &#39;c&#39;)                     # 获取指定成员的排名（排名以0为开始），</span>
<span class="sd">2                                                   # 之后可以根据这个排名来决定ZRANGE的访问范围。</span>
<span class="sd">&gt;&gt;&gt; conn.zcount(&#39;zset-key&#39;, 0, 3)                   # 对于某些任务来说，</span>
<span class="sd">2L                                                  # 统计给定分值范围内的元素数量非常有用。</span>
<span class="sd">&gt;&gt;&gt; conn.zrem(&#39;zset-key&#39;, &#39;b&#39;)                      # 从有序集合里面移除成员和添加成员一样容易。</span>
<span class="sd">True                                                #</span>
<span class="sd">&gt;&gt;&gt; conn.zrange(&#39;zset-key&#39;, 0, -1, withscores=True) # 在进行调试时，我们通常会使用ZRANGE取出有序集合里包含的所有元素，</span>
<span class="sd">[(&#39;a&#39;, 3.0), (&#39;c&#39;, 4.0)]                            # 但是在实际用例中，通常一次只会取出一小部分元素。</span>
<span class="sd"># &lt;end id=&quot;zset-calls-1&quot;/&gt;</span>
<span class="sd">&#39;&#39;&#39;</span>


<span class="c"># 代码清单 3-10</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd"># &lt;start id=&quot;zset-calls-2&quot;/&gt;</span>
<span class="sd">&gt;&gt;&gt; conn.zadd(&#39;zset-1&#39;, &#39;a&#39;, 1, &#39;b&#39;, 2, &#39;c&#39;, 3)                         # 首先创建两个有序集合。</span>
<span class="sd">3                                                                       #</span>
<span class="sd">&gt;&gt;&gt; conn.zadd(&#39;zset-2&#39;, &#39;b&#39;, 4, &#39;c&#39;, 1, &#39;d&#39;, 0)                         #</span>
<span class="sd">3                                                                       #</span>
<span class="sd">&gt;&gt;&gt; conn.zinterstore(&#39;zset-i&#39;, [&#39;zset-1&#39;, &#39;zset-2&#39;])                    # 因为ZINTERSTORE和ZUNIONSTORE默认使用的聚合函数为sum，</span>
<span class="sd">2L                                                                      # 所以多个有序集合里成员的分值将被加起来。</span>
<span class="sd">&gt;&gt;&gt; conn.zrange(&#39;zset-i&#39;, 0, -1, withscores=True)                       #</span>
<span class="sd">[(&#39;c&#39;, 4.0), (&#39;b&#39;, 6.0)]                                                #</span>
<span class="sd">&gt;&gt;&gt; conn.zunionstore(&#39;zset-u&#39;, [&#39;zset-1&#39;, &#39;zset-2&#39;], aggregate=&#39;min&#39;)   # 用户可以在执行并集运算和交集运算的时候传入不同的聚合函数，</span>
<span class="sd">4L                                                                      # 共有 sum、min、max 三个聚合函数可选。</span>
<span class="sd">&gt;&gt;&gt; conn.zrange(&#39;zset-u&#39;, 0, -1, withscores=True)                       #</span>
<span class="sd">[(&#39;d&#39;, 0.0), (&#39;a&#39;, 1.0), (&#39;c&#39;, 1.0), (&#39;b&#39;, 2.0)]                        #</span>
<span class="sd">&gt;&gt;&gt; conn.sadd(&#39;set-1&#39;, &#39;a&#39;, &#39;d&#39;)                                        # 用户还可以把集合作为输入传给ZINTERSTORE和ZUNIONSTORE，</span>
<span class="sd">2                                                                       # 命令会将集合看作是成员分值全为1的有序集合来处理。</span>
<span class="sd">&gt;&gt;&gt; conn.zunionstore(&#39;zset-u2&#39;, [&#39;zset-1&#39;, &#39;zset-2&#39;, &#39;set-1&#39;])          #</span>
<span class="sd">4L                                                                      #</span>
<span class="sd">&gt;&gt;&gt; conn.zrange(&#39;zset-u2&#39;, 0, -1, withscores=True)                      #</span>
<span class="sd">[(&#39;d&#39;, 1.0), (&#39;a&#39;, 2.0), (&#39;c&#39;, 4.0), (&#39;b&#39;, 6.0)]                        #</span>
<span class="sd"># &lt;end id=&quot;zset-calls-2&quot;/&gt;</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">def</span> <span class="nf">publisher</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">publish</span><span class="p">(</span><span class="s">&#39;channel&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">run_pubsub</span><span class="p">():</span>
    <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">publisher</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,))</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">pubsub</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">pubsub</span><span class="p">()</span>
    <span class="n">pubsub</span><span class="o">.</span><span class="n">subscribe</span><span class="p">([</span><span class="s">&#39;channel&#39;</span><span class="p">])</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">pubsub</span><span class="o">.</span><span class="n">listen</span><span class="p">():</span>
        <span class="k">print</span> <span class="n">item</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">pubsub</span><span class="o">.</span><span class="n">unsubscribe</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="k">break</span>


<span class="c"># 代码清单 3-11</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd"># &lt;start id=&quot;pubsub-calls-1&quot;/&gt;</span>
<span class="sd">&gt;&gt;&gt; def publisher(n):</span>
<span class="sd">...     time.sleep(1)                                                   # 函数在刚开始执行时会先休眠，让订阅者有足够的时间来连接服务器并监听消息。</span>
<span class="sd">...     for i in xrange(n):</span>
<span class="sd">...         conn.publish(&#39;channel&#39;, i)                                  # 在发布消息之后进行短暂的休眠，</span>
<span class="sd">...         time.sleep(1)                                               # 让消息可以一条接一条地出现。</span>
<span class="sd">...</span>
<span class="sd">&gt;&gt;&gt; def run_pubsub():</span>
<span class="sd">...     threading.Thread(target=publisher, args=(3,)).start()</span>
<span class="sd">...     pubsub = conn.pubsub()</span>
<span class="sd">...     pubsub.subscribe([&#39;channel&#39;])</span>
<span class="sd">...     count = 0</span>
<span class="sd">...     for item in pubsub.listen():</span>
<span class="sd">...         print item</span>
<span class="sd">...         count += 1</span>
<span class="sd">...         if count == 4:</span>
<span class="sd">...             pubsub.unsubscribe()</span>
<span class="sd">...         if count == 5:</span>
<span class="sd">...             break</span>
<span class="sd">... </span>

<span class="sd">&gt;&gt;&gt; def run_pubsub():</span>
<span class="sd">...     threading.Thread(target=publisher, args=(3,)).start()           # 启动发送者线程发送三条消息。</span>
<span class="sd">...     pubsub = conn.pubsub()                                          # 创建发布与订阅对象，并让它订阅给定的频道。</span>
<span class="sd">...     pubsub.subscribe([&#39;channel&#39;])                                   #</span>
<span class="sd">...     count = 0</span>
<span class="sd">...     for item in pubsub.listen():                                    # 通过遍历pubsub.listen()函数的执行结果来监听订阅消息。</span>
<span class="sd">...         print item                                                  # 打印接收到的每条消息。</span>
<span class="sd">...         count += 1                                                  # 在接收到一条订阅反馈消息和三条发布者发送的消息之后，</span>
<span class="sd">...         if count == 4:                                              # 执行退订操作，停止监听新消息。</span>
<span class="sd">...             pubsub.unsubscribe()                                    #</span>
<span class="sd">...         if count == 5:                                              # 当客户端接收到退订反馈消息时，</span>
<span class="sd">...             break                                                   # 需要停止接收消息。</span>
<span class="sd">...</span>
<span class="sd">&gt;&gt;&gt; run_pubsub()                                                        # 实际运行函数并观察它们的行为。</span>
<span class="sd">{&#39;pattern&#39;: None, &#39;type&#39;: &#39;subscribe&#39;, &#39;channel&#39;: &#39;channel&#39;, &#39;data&#39;: 1L}# 在刚开始订阅一个频道的时候，客户端会接收到一条关于被订阅频道的反馈消息。</span>
<span class="sd">{&#39;pattern&#39;: None, &#39;type&#39;: &#39;message&#39;, &#39;channel&#39;: &#39;channel&#39;, &#39;data&#39;: &#39;0&#39;} # 这些结构就是我们在遍历pubsub.listen()函数时得到的元素。</span>
<span class="sd">{&#39;pattern&#39;: None, &#39;type&#39;: &#39;message&#39;, &#39;channel&#39;: &#39;channel&#39;, &#39;data&#39;: &#39;1&#39;} #</span>
<span class="sd">{&#39;pattern&#39;: None, &#39;type&#39;: &#39;message&#39;, &#39;channel&#39;: &#39;channel&#39;, &#39;data&#39;: &#39;2&#39;} #</span>
<span class="sd">{&#39;pattern&#39;: None, &#39;type&#39;: &#39;unsubscribe&#39;, &#39;channel&#39;: &#39;channel&#39;, &#39;data&#39;:  # 在退订频道时，客户端会接收到一条反馈消息，</span>
<span class="sd">0L}                                                                     # 告知被退订的是哪个频道，以及客户端目前仍在订阅的频道数量。</span>
<span class="sd"># &lt;end id=&quot;pubsub-calls-1&quot;/&gt;</span>
<span class="sd">&#39;&#39;&#39;</span>


<span class="c"># 代码清单 3-12</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd"># &lt;start id=&quot;sort-calls&quot;/&gt;</span>
<span class="sd">&gt;&gt;&gt; conn.rpush(&#39;sort-input&#39;, 23, 15, 110, 7)                    # 首先将一些元素添加到列表里面。</span>
<span class="sd">4                                                               #</span>
<span class="sd">&gt;&gt;&gt; conn.sort(&#39;sort-input&#39;)                                     # 根据数字大小对元素进行排序。</span>
<span class="sd">[&#39;7&#39;, &#39;15&#39;, &#39;23&#39;, &#39;110&#39;]                                        #</span>
<span class="sd">&gt;&gt;&gt; conn.sort(&#39;sort-input&#39;, alpha=True)                         # 根据字母表顺序对元素进行排序。</span>
<span class="sd">[&#39;110&#39;, &#39;15&#39;, &#39;23&#39;, &#39;7&#39;]                                        #</span>
<span class="sd">&gt;&gt;&gt; conn.hset(&#39;d-7&#39;, &#39;field&#39;, 5)                                # 添加一些用于执行排序操作和获取操作的附加数据。</span>
<span class="sd">1L                                                              #</span>
<span class="sd">&gt;&gt;&gt; conn.hset(&#39;d-15&#39;, &#39;field&#39;, 1)                               #</span>
<span class="sd">1L                                                              #</span>
<span class="sd">&gt;&gt;&gt; conn.hset(&#39;d-23&#39;, &#39;field&#39;, 9)                               #</span>
<span class="sd">1L                                                              #</span>
<span class="sd">&gt;&gt;&gt; conn.hset(&#39;d-110&#39;, &#39;field&#39;, 3)                              #</span>
<span class="sd">1L                                                              #</span>
<span class="sd">&gt;&gt;&gt; conn.sort(&#39;sort-input&#39;, by=&#39;d-*-&gt;field&#39;)                    # 将散列的域（field）用作权重，对sort-input列表进行排序。</span>
<span class="sd">[&#39;15&#39;, &#39;110&#39;, &#39;7&#39;, &#39;23&#39;]                                        #</span>
<span class="sd">&gt;&gt;&gt; conn.sort(&#39;sort-input&#39;, by=&#39;d-*-&gt;field&#39;, get=&#39;d-*-&gt;field&#39;)  # 获取外部数据作为返回值，而不返回被排序的元素。</span>
<span class="sd">[&#39;1&#39;, &#39;3&#39;, &#39;5&#39;, &#39;9&#39;]                                            #</span>
<span class="sd"># &lt;end id=&quot;sort-calls&quot;/&gt;</span>
<span class="sd">&#39;&#39;&#39;</span>


<span class="c"># 代码清单 3-13</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd"># &lt;start id=&quot;simple-pipeline-notrans&quot;/&gt;</span>
<span class="sd">&gt;&gt;&gt; def notrans():</span>
<span class="sd">...     print conn.incr(&#39;notrans:&#39;)                     # 对‘notrans:’计数器执行自增操作并打印操作的执行结果。</span>
<span class="sd">...     time.sleep(.1)                                  # 等待100毫秒。</span>
<span class="sd">...     conn.incr(&#39;notrans:&#39;, -1)                       # 对‘notrans:’计数器执行自减操作。</span>
<span class="sd">...</span>
<span class="sd">&gt;&gt;&gt; if 1:</span>
<span class="sd">...     for i in xrange(3):                             # 启动三个线程来执行没有被事务包裹的自增、休眠和自减操作。</span>
<span class="sd">...         threading.Thread(target=notrans).start()    #</span>
<span class="sd">...     time.sleep(.5)                                  # 等待500毫秒，让操作有足够的时间完成。</span>
<span class="sd">...</span>
<span class="sd">1                                                       # 因为没有使用事务，</span>
<span class="sd">2                                                       # 所以三个线程执行的各个命令会互相交错，</span>
<span class="sd">3                                                       # 使得计数器的值持续地增大。</span>
<span class="sd"># &lt;end id=&quot;simple-pipeline-notrans&quot;/&gt;</span>
<span class="sd">&#39;&#39;&#39;</span>


<span class="c"># 代码清单 3-14</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd"># &lt;start id=&quot;simple-pipeline-trans&quot;/&gt;</span>
<span class="sd">&gt;&gt;&gt; def trans():</span>
<span class="sd">...     pipeline = conn.pipeline()                      # 创建一个事务型（transactional）流水线对象。</span>
<span class="sd">...     pipeline.incr(&#39;trans:&#39;)                         # 把针对‘trans:’计数器的自增操作放入队列。</span>
<span class="sd">...     time.sleep(.1)                                  # 等待100毫秒。</span>
<span class="sd">...     pipeline.incr(&#39;trans:&#39;, -1)                     # 把针对‘trans:’计数器的自减操作放入队列。</span>
<span class="sd">...     print pipeline.execute()[0]                     # 执行事务包含的命令并打印自增操作的执行结果。</span>
<span class="sd">...</span>
<span class="sd">&gt;&gt;&gt; if 1:</span>
<span class="sd">...     for i in xrange(3):                             # 启动三个线程来执行被事务包裹的自增、休眠和自减三个操作。</span>
<span class="sd">...         threading.Thread(target=trans).start()      #</span>
<span class="sd">...     time.sleep(.5)                                  # 等待500毫秒，让操作有足够的时间完成。</span>
<span class="sd">...</span>
<span class="sd">1                                                       # 因为每组自增、休眠和自减操作都在事务里面执行，</span>
<span class="sd">1                                                       # 所以命令之间不会互相交错，</span>
<span class="sd">1                                                       # 因此所有事务的执行结果都是1。</span>
<span class="sd"># &lt;end id=&quot;simple-pipeline-trans&quot;/&gt;</span>
<span class="sd">&#39;&#39;&#39;</span>


<span class="c"># &lt;start id=&quot;exercise-fix-article-vote&quot;/&gt;</span>
<span class="k">def</span> <span class="nf">article_vote</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="n">article</span><span class="p">):</span>
    <span class="c"># 在进行投票之前，先检查这篇文章是否仍然处于可投票的时间之内</span>
    <span class="n">cutoff</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">ONE_WEEK_IN_SECONDS</span>
    <span class="n">posted</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">zscore</span><span class="p">(</span><span class="s">&#39;time:&#39;</span><span class="p">,</span> <span class="n">article</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">posted</span> <span class="o">&lt;</span> <span class="n">cutoff</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="n">article_id</span> <span class="o">=</span> <span class="n">article</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s">&#39;:&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">pipeline</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">pipeline</span><span class="p">()</span>
    <span class="n">pipeline</span><span class="o">.</span><span class="n">sadd</span><span class="p">(</span><span class="s">&#39;voted:&#39;</span> <span class="o">+</span> <span class="n">article_id</span><span class="p">,</span> <span class="n">user</span><span class="p">)</span>
    <span class="c"># 为文章的投票设置过期时间</span>
    <span class="n">pipeline</span><span class="o">.</span><span class="n">expire</span><span class="p">(</span><span class="s">&#39;voted:&#39;</span> <span class="o">+</span> <span class="n">article_id</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">posted</span><span class="o">-</span><span class="n">cutoff</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">execute</span><span class="p">()[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="c"># 因为客户端可能会在执行 SADD/EXPIRE 之间或者执行 ZINCRBY/HINCRBY 之间掉线</span>
        <span class="c"># 所以投票可能会不被计数，但这总比在执行 ZINCRBY/HINCRBY 之间失败并导致不完整的计数要好</span>
        <span class="n">pipeline</span><span class="o">.</span><span class="n">zincrby</span><span class="p">(</span><span class="s">&#39;score:&#39;</span><span class="p">,</span> <span class="n">article</span><span class="p">,</span> <span class="n">VOTE_SCORE</span><span class="p">)</span>
        <span class="n">pipeline</span><span class="o">.</span><span class="n">hincrby</span><span class="p">(</span><span class="n">article</span><span class="p">,</span> <span class="s">&#39;votes&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">pipeline</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span>
<span class="c"># &lt;end id=&quot;exercise-fix-article-vote&quot;/&gt;</span>

<span class="c"># 从技术上来将，上面的 article_vote() 函数仍然有一些问题，</span>
<span class="c"># 这些问题可以通过下面展示的这段代码来解决，</span>
<span class="c"># 这段代码里面用到了本书第 4 章才会介绍的技术</span>

<span class="k">def</span> <span class="nf">article_vote</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="n">article</span><span class="p">):</span>
    <span class="n">cutoff</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">ONE_WEEK_IN_SECONDS</span>
    <span class="n">posted</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">zscore</span><span class="p">(</span><span class="s">&#39;time:&#39;</span><span class="p">,</span> <span class="n">article</span><span class="p">)</span>
    <span class="n">article_id</span> <span class="o">=</span> <span class="n">article</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s">&#39;:&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">voted</span> <span class="o">=</span> <span class="s">&#39;voted:&#39;</span> <span class="o">+</span> <span class="n">article_id</span>

    <span class="n">pipeline</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">pipeline</span><span class="p">()</span>
    <span class="k">while</span> <span class="n">posted</span> <span class="o">&gt;</span> <span class="n">cutoff</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">pipeline</span><span class="o">.</span><span class="n">watch</span><span class="p">(</span><span class="n">voted</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">sismember</span><span class="p">(</span><span class="n">voted</span><span class="p">,</span> <span class="n">user</span><span class="p">):</span>
                <span class="n">pipeline</span><span class="o">.</span><span class="n">multi</span><span class="p">()</span>
                <span class="n">pipeline</span><span class="o">.</span><span class="n">sadd</span><span class="p">(</span><span class="n">voted</span><span class="p">,</span> <span class="n">user</span><span class="p">)</span>
                <span class="n">pipeline</span><span class="o">.</span><span class="n">expire</span><span class="p">(</span><span class="n">voted</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">posted</span><span class="o">-</span><span class="n">cutoff</span><span class="p">))</span>
                <span class="n">pipeline</span><span class="o">.</span><span class="n">zincrby</span><span class="p">(</span><span class="s">&#39;score:&#39;</span><span class="p">,</span> <span class="n">article</span><span class="p">,</span> <span class="n">VOTE_SCORE</span><span class="p">)</span>
                <span class="n">pipeline</span><span class="o">.</span><span class="n">hincrby</span><span class="p">(</span><span class="n">article</span><span class="p">,</span> <span class="s">&#39;votes&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">pipeline</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pipeline</span><span class="o">.</span><span class="n">unwatch</span><span class="p">()</span>
            <span class="k">return</span>
        <span class="k">except</span> <span class="n">redis</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">WatchError</span><span class="p">:</span>
            <span class="n">cutoff</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">ONE_WEEK_IN_SECONDS</span>

<span class="c"># &lt;start id=&quot;exercise-fix-get_articles&quot;/&gt;</span>
<span class="k">def</span> <span class="nf">get_articles</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;score:&#39;</span><span class="p">):</span>
    <span class="n">start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">page</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">ARTICLES_PER_PAGE</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">ARTICLES_PER_PAGE</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="n">ids</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">zrevrangebyscore</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

    <span class="n">pipeline</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">pipeline</span><span class="p">()</span>
    <span class="c"># 将等待执行的多个 HGETALL 调用放入流水线</span>
    <span class="nb">map</span><span class="p">(</span><span class="n">pipeline</span><span class="o">.</span><span class="n">hgetall</span><span class="p">,</span> <span class="n">ids</span><span class="p">)</span>                              <span class="c">#A</span>

    <span class="n">articles</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c"># 执行被流水线包含的多个 HGETALL 命令，</span>
    <span class="c"># 并将执行所得的多个 id 添加到 articles 变量里面</span>
    <span class="k">for</span> <span class="nb">id</span><span class="p">,</span> <span class="n">article_data</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">execute</span><span class="p">()):</span>   <span class="c">#B</span>
        <span class="n">article_data</span><span class="p">[</span><span class="s">&#39;id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">id</span>
        <span class="n">articles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">article_data</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">articles</span>
<span class="c"># &lt;end id=&quot;exercise-fix-get_articles&quot;/&gt;</span>


<span class="c"># 代码清单 3-15</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd"># &lt;start id=&quot;other-calls-1&quot;/&gt;</span>
<span class="sd">&gt;&gt;&gt; conn.set(&#39;key&#39;, &#39;value&#39;)                    # 设置一个简单的字符串值，作为过期时间的设置对象。</span>
<span class="sd">True                                            #</span>
<span class="sd">&gt;&gt;&gt; conn.get(&#39;key&#39;)                             #</span>
<span class="sd">&#39;value&#39;                                         #</span>
<span class="sd">&gt;&gt;&gt; conn.expire(&#39;key&#39;, 2)                       # 如果我们为键设置了过期时间，那么当键过期后，</span>
<span class="sd">True                                            # 我们再尝试去获取键时，会发现键已经被删除了。</span>
<span class="sd">&gt;&gt;&gt; time.sleep(2)                               #</span>
<span class="sd">&gt;&gt;&gt; conn.get(&#39;key&#39;)                             #</span>
<span class="sd">&gt;&gt;&gt; conn.set(&#39;key&#39;, &#39;value2&#39;)</span>
<span class="sd">True</span>
<span class="sd">&gt;&gt;&gt; conn.expire(&#39;key&#39;, 100); conn.ttl(&#39;key&#39;)    # 还可以很容易地查到键距离过期时间还有多久。</span>
<span class="sd">True                                            #</span>
<span class="sd">100                                             #</span>
<span class="sd"># &lt;end id=&quot;other-calls-1&quot;/&gt;</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="c"># &lt;start id=&quot;exercise-no-recent-zset&quot;/&gt;</span>
<span class="n">THIRTY_DAYS</span> <span class="o">=</span> <span class="mi">30</span><span class="o">*</span><span class="mi">86400</span>
<span class="k">def</span> <span class="nf">check_token</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">token</span><span class="p">):</span>
    <span class="c"># 为了能够对登录令牌进行过期，我们将把它存储为字符串值</span>
    <span class="k">return</span> <span class="n">conn</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;login:&#39;</span> <span class="o">+</span> <span class="n">token</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">update_token</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">token</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="n">item</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="c"># 在一次命令调用里面，同时为字符串键设置值和过期时间</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">setex</span><span class="p">(</span><span class="s">&#39;login:&#39;</span> <span class="o">+</span> <span class="n">token</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="n">THIRTY_DAYS</span><span class="p">)</span>
    <span class="n">key</span> <span class="o">=</span> <span class="s">&#39;viewed:&#39;</span> <span class="o">+</span> <span class="n">token</span>
    <span class="k">if</span> <span class="n">item</span><span class="p">:</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">lrem</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">rpush</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">ltrim</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="o">-</span><span class="mi">25</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="c"># 跟字符串不一样，Redis 并没有提供能够在操作列表的同时，</span>
    <span class="c"># 为列表设置过期时间的命令，</span>
    <span class="c"># 所以我们需要在这里调用 EXPIRE 命令来为列表设置过期时间</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">expire</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">THIRTY_DAYS</span><span class="p">)</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">zincrby</span><span class="p">(</span><span class="s">&#39;viewed:&#39;</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">add_to_cart</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">session</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
    <span class="n">key</span> <span class="o">=</span> <span class="s">&#39;cart:&#39;</span> <span class="o">+</span> <span class="n">session</span>
    <span class="k">if</span> <span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">hrem</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">hset</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
    <span class="c"># 散列也和列表一样，需要通过调用 EXPIRE 命令来设置过期时间</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">expire</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">THIRTY_DAYS</span><span class="p">)</span>
<span class="c"># &lt;end id=&quot;exercise-no-recent-zset&quot;/&gt;</span>
</pre></div>
</div>
</div>



            <div class="section" id="discuss">
    <h2>
        讨论
        <a class="headerlink" href="#discuss" title="永久链接至标题">¶</a>
    </h2>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'redisinaction'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="chapter4.html" title="第 4 章相关源代码"
             >next</a> |</li>
        <li class="right" >
          <a href="chapter2.html" title="第 2 章相关源代码"
             >previous</a> |</li>
        <li><a href="../index.html">Redis 实战</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, 黄健宏（huangz）.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>